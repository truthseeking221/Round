import { describe, it, expect, beforeEach } from "vitest";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { Address, Cell, beginCell, toNano } from "@ton/core";
import { keyPairFromSeed, sign } from "@ton/crypto";
import { randomBytes } from "crypto";

// These wrappers are generated by `tact compile` into `build/`.
// eslint-disable-next-line import/no-unresolved
import { CircleContract } from "../build/CircleContract_CircleContract";
// eslint-disable-next-line import/no-unresolved
import { JettonWalletMock } from "../build/JettonWalletMock_JettonWalletMock";

const OP_JOIN_WITH_TICKET = 0x1001;
const OP_TRIGGER_DEBIT_ALL = 0x2001;
const OP_COMMIT_BID = 0x3001;
const OP_REVEAL_BID = 0x3002;
const OP_FINALIZE_AUCTION = 0x3003;
const OP_TERMINATE_DEFAULT = 0x4001;
const OP_WITHDRAW = 0x6001;
const OP_EMERGENCY_STOP = 0x9001;

const OP_JETTON_TRANSFER_NOTIFICATION = 0x7362d09c;

const OP_TAKE_WALLET_ADDRESS = 0x3;

const OP_TEST_SEND_NOTIFICATION = 0xaa01;
const OP_TEST_SET_BOUNCE = 0xaa02;

const DEPOSIT_MAGIC = 0xc0ffee01;
const PURPOSE_COLLATERAL = 1;
const PURPOSE_PREFUND = 2;

const ERR_EMERGENCY_STOP = 100;
const ERR_NOT_RECRUITING = 101;
const ERR_SENDER_NOT_JETTON_WALLET = 122;
const ERR_NOT_FUNDING_PHASE = 140;
const ERR_NOT_COMMIT_PHASE = 142;
const ERR_REVEAL_CLOSED = 146;
const ERR_NOT_DEFAULT_ELIGIBLE = 170;
const ERR_STOP_NONCE_USED = 212;

function u256From(buf: Buffer): bigint {
  return BigInt(`0x${buf.toString("hex")}`);
}

function buildJoinHash(contract: Address, wallet: Address, exp: number, nonce: bigint): Buffer {
  return beginCell()
    .storeUint(0x4d43, 16) // "MC"
    .storeUint(0x5f4a4f494e, 40) // "_JOIN"
    .storeAddress(contract)
    .storeAddress(wallet)
    .storeUint(exp, 32)
    .storeUint(nonce, 64)
    .endCell()
    .hash();
}

function buildBidHash(contract: Address, cycleIndex: number, wallet: Address, payoutWanted: bigint, salt: bigint): Buffer {
  return beginCell()
    .storeUint(0x4d43, 16) // "MC"
    .storeUint(0x5f424944, 32) // "_BID"
    .storeAddress(contract)
    .storeUint(cycleIndex, 16)
    .storeAddress(wallet)
    .storeCoins(payoutWanted)
    .storeUint(salt, 256)
    .endCell()
    .hash();
}

function buildStopHash(contract: Address, reason: number, exp: number, nonce: bigint): Buffer {
  return beginCell()
    .storeUint(0x4d43, 16) // "MC"
    .storeUint(0x5f53544f50, 40) // "_STOP"
    .storeAddress(contract)
    .storeUint(reason, 32)
    .storeUint(exp, 32)
    .storeUint(nonce, 64)
    .endCell()
    .hash();
}

async function sendBody(from: SandboxContract<TreasuryContract>, to: Address, body: Cell, value: bigint) {
  return await from.send({
    to,
    value,
    body
  });
}

async function deployContract(contract: SandboxContract<any>, via: SandboxContract<TreasuryContract>, value: bigint) {
  await contract.send(via.getSender(), { value }, { $$type: "Deploy", queryId: 0n });
}

function txTo(result: any, address: Address) {
  const target = address.toString();
  return result.transactions.find((t: any) => t.inMessage?.info?.dest?.toString?.() === target);
}

function expectTxSuccess(result: any, address: Address) {
  const tx = txTo(result, address);
  expect(tx?.description?.computePhase?.success).toBe(true);
}

function expectTxFail(result: any, address: Address, exitCode?: number) {
  const tx = txTo(result, address);
  expect(tx?.description?.computePhase?.success).toBe(false);
  if (exitCode !== undefined) {
    expect(tx?.description?.computePhase?.exitCode).toBe(exitCode);
  }
}

describe("CircleContract v1.2.1", () => {
  let blockchain: Blockchain;
  let deployer: SandboxContract<TreasuryContract>;
  let jettonMaster: SandboxContract<TreasuryContract>;
  let treasuryOwner: SandboxContract<TreasuryContract>;
  let guardianKeypair: ReturnType<typeof keyPairFromSeed>;

  beforeEach(async () => {
    blockchain = await Blockchain.create();
    blockchain.now = 1_700_000_000; // deterministic-ish timestamp
    deployer = await blockchain.treasury("deployer");
    jettonMaster = await blockchain.treasury("jettonMaster");
    treasuryOwner = await blockchain.treasury("treasuryOwner");
    guardianKeypair = keyPairFromSeed(randomBytes(32));
  });

  it("allows payout-only withdraw in Active (fix #1) and does not touch other buckets", async () => {
    const memberA = await blockchain.treasury("memberA");
    const memberB = await blockchain.treasury("memberB");

    const jettonWallet = blockchain.openContract(await JettonWalletMock.fromInit(false));
    await deployContract(jettonWallet, deployer, toNano("0.2"));

    const circle = blockchain.openContract(
      await CircleContract.fromInit({
        $$type: "Config",
        jetton_master: jettonMaster.address,
        guardian_pubkey: u256From(guardianKeypair.publicKey),
        treasury_owner: treasuryOwner.address,
        n_members: 2n,
        contribution: 1_000_000n,
        total_cycles: 2n,
        interval_sec: 0n,
        grace_sec: 3600n,
        take_rate_bps: 100n,
        collateral_rate_bps: 0n,
        max_discount_bps: 500n,
        vesting_bps_cycle1: 2000n,
        early_lock_rate_bps_cycle1: 3000n,
        commit_duration_sec: 10n,
        reveal_duration_sec: 10n,
        max_pot_cap: 10_000_000n,
        min_deposit_units: 1n
      })
    );
    await deployContract(circle, deployer, toNano("0.5"));

    // Set jetton_wallet via take_wallet_address from jetton master
    const takeWallet = beginCell()
      .storeUint(OP_TAKE_WALLET_ADDRESS, 32)
      .storeUint(1, 64)
      .storeAddress(jettonWallet.address)
      .endCell();
    await sendBody(jettonMaster, circle.address, takeWallet, toNano("0.2"));
    expect((await circle.getGetJettonWallet())?.toString()).toEqual(jettonWallet.address.toString());
    const jw = await circle.getGetJettonWallet();
    expect(jw?.toString()).toEqual(jettonWallet.address.toString());

    // Join 2 members with signed tickets
    const exp = blockchain.now + 600;
    const nonceA = 1n;
    const sigA = sign(buildJoinHash(circle.address, memberA.address, exp, nonceA), guardianKeypair.secretKey);
    const joinA = beginCell()
      .storeUint(OP_JOIN_WITH_TICKET, 32)
      .storeAddress(memberA.address)
      .storeUint(exp, 32)
      .storeUint(nonceA, 64)
      .storeBuffer(sigA)
      .endCell();
    await sendBody(memberA, circle.address, joinA, toNano("0.2"));

    const nonceB = 2n;
    const sigB = sign(buildJoinHash(circle.address, memberB.address, exp, nonceB), guardianKeypair.secretKey);
    const joinB = beginCell()
      .storeUint(OP_JOIN_WITH_TICKET, 32)
      .storeAddress(memberB.address)
      .storeUint(exp, 32)
      .storeUint(nonceB, 64)
      .storeBuffer(sigB)
      .endCell();
    await sendBody(memberB, circle.address, joinB, toNano("0.2"));

    expect(await circle.getGetMembersCount()).toEqual(2n);
    const statusAfterJoin = await circle.getGetStatus();
    expect(statusAfterJoin.status).toEqual(1n); // Locked
    expect(statusAfterJoin.current_cycle).toEqual(1n);
    expect(statusAfterJoin.phase).toEqual(0n); // Funding

    // Deposit prefund for both (via mock notifications)
    const depositA = beginCell()
      .storeUint(OP_TEST_SEND_NOTIFICATION, 32)
      .storeAddress(circle.address)
      .storeUint(11, 64)
      .storeCoins(1_000_000n)
      .storeAddress(memberA.address)
      .storeUint(PURPOSE_PREFUND, 8)
      .endCell();
    await sendBody(deployer, jettonWallet.address, depositA, toNano("0.2"));

    const depositB = beginCell()
      .storeUint(OP_TEST_SEND_NOTIFICATION, 32)
      .storeAddress(circle.address)
      .storeUint(12, 64)
      .storeCoins(1_000_000n)
      .storeAddress(memberB.address)
      .storeUint(PURPOSE_PREFUND, 8)
      .endCell();
    await sendBody(deployer, jettonWallet.address, depositB, toNano("0.2"));

    const statusAfterFunding = await circle.getGetStatus();
    expect(statusAfterFunding.status).toEqual(2n); // Active
    expect(statusAfterFunding.phase).toEqual(1n); // Commit
    expect(statusAfterFunding.funded_count).toEqual(2n);

    // Commit bids
    const cycleIndex = 1;
    const pot = 2_000_000n;
    const payoutA = 1_900_000n; // minPayout for 5% discount
    const saltA = u256From(randomBytes(32));
    const commitHashA = u256From(buildBidHash(circle.address, cycleIndex, memberA.address, payoutA, saltA));
    const commitA = beginCell().storeUint(OP_COMMIT_BID, 32).storeUint(commitHashA, 256).endCell();
    await sendBody(memberA, circle.address, commitA, toNano("0.2"));

    const payoutB = pot;
    const saltB = u256From(randomBytes(32));
    const commitHashB = u256From(buildBidHash(circle.address, cycleIndex, memberB.address, payoutB, saltB));
    const commitB = beginCell().storeUint(OP_COMMIT_BID, 32).storeUint(commitHashB, 256).endCell();
    await sendBody(memberB, circle.address, commitB, toNano("0.2"));

    // Move time to reveal phase and reveal
    blockchain.now += 10;
    const revealA = beginCell().storeUint(OP_REVEAL_BID, 32).storeCoins(payoutA).storeUint(saltA, 256).endCell();
    await sendBody(memberA, circle.address, revealA, toNano("0.2"));
    const revealB = beginCell().storeUint(OP_REVEAL_BID, 32).storeCoins(payoutB).storeUint(saltB, 256).endCell();
    await sendBody(memberB, circle.address, revealB, toNano("0.2"));

    // Finalize after reveal_end
    blockchain.now += 10;
    const finalize = beginCell().storeUint(OP_FINALIZE_AUCTION, 32).endCell();
    await sendBody(memberA, circle.address, finalize, toNano("0.2"));

    const statusAfterFinalize = await circle.getGetStatus();
    expect(statusAfterFinalize.status).toEqual(2n); // Active (cycle 2 funding)
    expect(statusAfterFinalize.current_cycle).toEqual(2n);
    expect(statusAfterFinalize.phase).toEqual(0n); // Funding

    // Winner is memberA; status should be Active (cycle 2 started) and withdrawable > 0
    const memberAStateBefore = await circle.getGetMember(memberA.address);
    const withdrawableBefore = memberAStateBefore.withdrawable;
    const futureLockedBefore = memberAStateBefore.future_locked;
    const vestingLockedBefore = memberAStateBefore.vesting_locked;
    expect(withdrawableBefore).toBeGreaterThan(0n);
    expect(futureLockedBefore).toBeGreaterThan(0n);
    expect(vestingLockedBefore).toBeGreaterThan(0n);

    // Withdraw payout-only in Active (mode=1)
    const withdraw = beginCell().storeUint(OP_WITHDRAW, 32).storeUint(1, 8).endCell();
    await sendBody(memberA, circle.address, withdraw, toNano("0.2"));

    const memberAStateAfter = await circle.getGetMember(memberA.address);
    expect(memberAStateAfter.withdrawable).toEqual(0n); // withdrawable cleared
    expect(memberAStateAfter.future_locked).toEqual(futureLockedBefore); // unchanged
    expect(memberAStateAfter.vesting_locked).toEqual(vestingLockedBefore); // unchanged
  });

  it("seizes future_locked on terminateDefault (fix #2) and prevents defaulter escape", async () => {
    const winner = await blockchain.treasury("winner");
    const other = await blockchain.treasury("other");

    const jettonWallet = blockchain.openContract(await JettonWalletMock.fromInit(false));
    await deployContract(jettonWallet, deployer, toNano("0.2"));

    const circle = blockchain.openContract(
      await CircleContract.fromInit({
        $$type: "Config",
        jetton_master: jettonMaster.address,
        guardian_pubkey: u256From(guardianKeypair.publicKey),
        treasury_owner: treasuryOwner.address,
        n_members: 2n,
        contribution: 1_000_000n,
        total_cycles: 2n,
        interval_sec: 0n,
        grace_sec: 100n,
        take_rate_bps: 100n,
        collateral_rate_bps: 1000n,
        max_discount_bps: 500n,
        vesting_bps_cycle1: 2000n,
        early_lock_rate_bps_cycle1: 3000n,
        commit_duration_sec: 5n,
        reveal_duration_sec: 5n,
        max_pot_cap: 10_000_000n,
        min_deposit_units: 1n
      })
    );
    await deployContract(circle, deployer, toNano("0.5"));

    // Set jetton_wallet
    const takeWallet = beginCell()
      .storeUint(OP_TAKE_WALLET_ADDRESS, 32)
      .storeUint(1, 64)
      .storeAddress(jettonWallet.address)
      .endCell();
    await sendBody(jettonMaster, circle.address, takeWallet, toNano("0.2"));

    // Join 2 members (winner is first in list)
    const exp = blockchain.now + 600;
    const sigW = sign(buildJoinHash(circle.address, winner.address, exp, 1n), guardianKeypair.secretKey);
    await sendBody(
      winner,
      circle.address,
      beginCell().storeUint(OP_JOIN_WITH_TICKET, 32).storeAddress(winner.address).storeUint(exp, 32).storeUint(1n, 64).storeBuffer(sigW).endCell(),
      toNano("0.2")
    );
    const sigO = sign(buildJoinHash(circle.address, other.address, exp, 2n), guardianKeypair.secretKey);
    await sendBody(
      other,
      circle.address,
      beginCell().storeUint(OP_JOIN_WITH_TICKET, 32).storeAddress(other.address).storeUint(exp, 32).storeUint(2n, 64).storeBuffer(sigO).endCell(),
      toNano("0.2")
    );

    expect(await circle.getGetMembersCount()).toEqual(2n);

    // Required collateral per member = pot * 10% = 0.2 USDT
    const requiredCollateral = 200_000n;

    // Deposit collateral + prefund to fund cycle 1 for both
    for (const [qid, who] of [
      [11, winner],
      [12, other]
    ] as const) {
      const depCol = beginCell()
        .storeUint(OP_TEST_SEND_NOTIFICATION, 32)
        .storeAddress(circle.address)
        .storeUint(qid, 64)
        .storeCoins(requiredCollateral)
        .storeAddress(who.address)
        .storeUint(PURPOSE_COLLATERAL, 8)
        .endCell();
      await sendBody(deployer, jettonWallet.address, depCol, toNano("0.2"));

      const depPre = beginCell()
        .storeUint(OP_TEST_SEND_NOTIFICATION, 32)
        .storeAddress(circle.address)
        .storeUint(qid + 100, 64)
        .storeCoins(1_000_000n)
        .storeAddress(who.address)
        .storeUint(PURPOSE_PREFUND, 8)
        .endCell();
      await sendBody(deployer, jettonWallet.address, depPre, toNano("0.2"));
    }

    const statusAfterFunding = await circle.getGetStatus();
    expect(statusAfterFunding.status).toEqual(2n); // Active
    expect(statusAfterFunding.phase).toEqual(1n); // Commit
    expect(statusAfterFunding.funded_count).toEqual(2n);

    // Only winner commits, no one reveals -> fallback winner is `winner`, but winner gets non-reveal penalty (collateral drops below required)
    const payout = 2_000_000n; // pot
    const salt = u256From(randomBytes(32));
    const commitHash = u256From(buildBidHash(circle.address, 1, winner.address, payout, salt));
    await sendBody(winner, circle.address, beginCell().storeUint(OP_COMMIT_BID, 32).storeUint(commitHash, 256).endCell(), toNano("0.2"));

    // Move time past reveal_end and finalize (no reveals)
    blockchain.now += 20;
    await sendBody(winner, circle.address, beginCell().storeUint(OP_FINALIZE_AUCTION, 32).endCell(), toNano("0.2"));

    const statusAfterFinalize = await circle.getGetStatus();
    expect(statusAfterFinalize.status).toEqual(2n); // Active (cycle 2 funding)
    expect(statusAfterFinalize.current_cycle).toEqual(2n);
    expect(statusAfterFinalize.phase).toEqual(0n); // Funding

    const w1 = await circle.getGetMember(winner.address);
    const futureLocked = w1.future_locked;
    expect(futureLocked).toBeGreaterThan(0n);

    // Cycle 2: fund only `other` so default happens (winner has collateral slightly below required and no prefund to auto-heal)
    const depOtherCol = beginCell()
      .storeUint(OP_TEST_SEND_NOTIFICATION, 32)
      .storeAddress(circle.address)
      .storeUint(201, 64)
      .storeCoins(requiredCollateral)
      .storeAddress(other.address)
      .storeUint(PURPOSE_COLLATERAL, 8)
      .endCell();
    await sendBody(deployer, jettonWallet.address, depOtherCol, toNano("0.2"));
    const depOtherPre = beginCell()
      .storeUint(OP_TEST_SEND_NOTIFICATION, 32)
      .storeAddress(circle.address)
      .storeUint(202, 64)
      .storeCoins(1_000_000n)
      .storeAddress(other.address)
      .storeUint(PURPOSE_PREFUND, 8)
      .endCell();
    await sendBody(deployer, jettonWallet.address, depOtherPre, toNano("0.2"));

    // Ensure debit loop runs for completeness
    await sendBody(other, circle.address, beginCell().storeUint(OP_TRIGGER_DEBIT_ALL, 32).endCell(), toNano("0.2"));

    // Move past grace end and terminate
    blockchain.now += 200;
    await sendBody(other, circle.address, beginCell().storeUint(OP_TERMINATE_DEFAULT, 32).endCell(), toNano("0.2"));

    const wAfter = await circle.getGetMember(winner.address);
    expect(wAfter.future_locked).toEqual(0n); // future_locked seized
  });

  it("auto-heals missing collateral from prefund before gate (fix #3), preventing false default", async () => {
    const winner = await blockchain.treasury("winner2");
    const other = await blockchain.treasury("other2");

    const jettonWallet = blockchain.openContract(await JettonWalletMock.fromInit(false));
    await deployContract(jettonWallet, deployer, toNano("0.2"));

    const circle = blockchain.openContract(
      await CircleContract.fromInit({
        $$type: "Config",
        jetton_master: jettonMaster.address,
        guardian_pubkey: u256From(guardianKeypair.publicKey),
        treasury_owner: treasuryOwner.address,
        n_members: 2n,
        contribution: 1_000_000n,
        total_cycles: 2n,
        interval_sec: 0n,
        grace_sec: 100n,
        take_rate_bps: 100n,
        collateral_rate_bps: 1000n,
        max_discount_bps: 500n,
        vesting_bps_cycle1: 2000n,
        early_lock_rate_bps_cycle1: 3000n,
        commit_duration_sec: 5n,
        reveal_duration_sec: 5n,
        max_pot_cap: 10_000_000n,
        min_deposit_units: 1n
      })
    );
    await deployContract(circle, deployer, toNano("0.5"));

    // Set jetton_wallet
    await sendBody(
      jettonMaster,
      circle.address,
      beginCell().storeUint(OP_TAKE_WALLET_ADDRESS, 32).storeUint(1, 64).storeAddress(jettonWallet.address).endCell(),
      toNano("0.2")
    );
    expect((await circle.getGetJettonWallet())?.toString()).toEqual(jettonWallet.address.toString());

    // Join 2 members
    const exp = blockchain.now + 600;
    await sendBody(
      winner,
      circle.address,
      beginCell()
        .storeUint(OP_JOIN_WITH_TICKET, 32)
        .storeAddress(winner.address)
        .storeUint(exp, 32)
        .storeUint(1n, 64)
        .storeBuffer(sign(buildJoinHash(circle.address, winner.address, exp, 1n), guardianKeypair.secretKey))
        .endCell(),
      toNano("0.2")
    );
    await sendBody(
      other,
      circle.address,
      beginCell()
        .storeUint(OP_JOIN_WITH_TICKET, 32)
        .storeAddress(other.address)
        .storeUint(exp, 32)
        .storeUint(2n, 64)
        .storeBuffer(sign(buildJoinHash(circle.address, other.address, exp, 2n), guardianKeypair.secretKey))
        .endCell(),
      toNano("0.2")
    );

    expect(await circle.getGetMembersCount()).toEqual(2n);

    const requiredCollateral = 200_000n;

    // Deposit collateral+prefund for both in cycle 1
    for (const [qid, who] of [
      [11, winner],
      [12, other]
    ] as const) {
      await sendBody(
        deployer,
        jettonWallet.address,
        beginCell().storeUint(OP_TEST_SEND_NOTIFICATION, 32).storeAddress(circle.address).storeUint(qid, 64).storeCoins(requiredCollateral).storeAddress(who.address).storeUint(PURPOSE_COLLATERAL, 8).endCell(),
        toNano("0.2")
      );
      await sendBody(
        deployer,
        jettonWallet.address,
        beginCell().storeUint(OP_TEST_SEND_NOTIFICATION, 32).storeAddress(circle.address).storeUint(qid + 100, 64).storeCoins(1_000_000n).storeAddress(who.address).storeUint(PURPOSE_PREFUND, 8).endCell(),
        toNano("0.2")
      );
    }

    const statusAfterFunding = await circle.getGetStatus();
    expect(statusAfterFunding.status).toEqual(2n);
    expect(statusAfterFunding.phase).toEqual(1n);
    expect(statusAfterFunding.funded_count).toEqual(2n);

    // Winner commits, no reveals -> winner gets non-reveal penalty, collateral slightly below required in cycle 2.
    const payout = 2_000_000n;
    const salt = u256From(randomBytes(32));
    const commitHash = u256From(buildBidHash(circle.address, 1, winner.address, payout, salt));
    await sendBody(winner, circle.address, beginCell().storeUint(OP_COMMIT_BID, 32).storeUint(commitHash, 256).endCell(), toNano("0.2"));
    blockchain.now += 20;
    await sendBody(winner, circle.address, beginCell().storeUint(OP_FINALIZE_AUCTION, 32).endCell(), toNano("0.2"));

    const statusAfterFinalize = await circle.getGetStatus();
    expect(statusAfterFinalize.status).toEqual(2n); // Active (cycle 2 started)
    expect(statusAfterFinalize.current_cycle).toEqual(2n);
    expect(statusAfterFinalize.phase).toEqual(0n); // Funding

    // Cycle 2: deposit prefund for winner (enough to cover missing collateral + contribution)
    await sendBody(
      deployer,
      jettonWallet.address,
      beginCell().storeUint(OP_TEST_SEND_NOTIFICATION, 32).storeAddress(circle.address).storeUint(301, 64).storeCoins(1_010_000n).storeAddress(winner.address).storeUint(PURPOSE_PREFUND, 8).endCell(),
      toNano("0.2")
    );
    await sendBody(
      deployer,
      jettonWallet.address,
      beginCell().storeUint(OP_TEST_SEND_NOTIFICATION, 32).storeAddress(circle.address).storeUint(302, 64).storeCoins(requiredCollateral).storeAddress(other.address).storeUint(PURPOSE_COLLATERAL, 8).endCell(),
      toNano("0.2")
    );
    await sendBody(
      deployer,
      jettonWallet.address,
      beginCell().storeUint(OP_TEST_SEND_NOTIFICATION, 32).storeAddress(circle.address).storeUint(303, 64).storeCoins(1_000_000n).storeAddress(other.address).storeUint(PURPOSE_PREFUND, 8).endCell(),
      toNano("0.2")
    );

    // Trigger debit all to make funding deterministic
    await sendBody(other, circle.address, beginCell().storeUint(OP_TRIGGER_DEBIT_ALL, 32).endCell(), toNano("0.2"));

    const wAfter = await circle.getGetMember(winner.address);
    expect(wAfter.due_remaining).toEqual(0n); // due_remaining == 0
  });

  it("rejects commit after commit_end (C18)", async () => {
    const memberA = await blockchain.treasury("commitLateA");
    const memberB = await blockchain.treasury("commitLateB");

    const jettonWallet = blockchain.openContract(await JettonWalletMock.fromInit(false));
    await deployContract(jettonWallet, deployer, toNano("0.2"));

    const circle = blockchain.openContract(
      await CircleContract.fromInit({
        $$type: "Config",
        jetton_master: jettonMaster.address,
        guardian_pubkey: u256From(guardianKeypair.publicKey),
        treasury_owner: treasuryOwner.address,
        n_members: 2n,
        contribution: 1_000_000n,
        total_cycles: 2n,
        interval_sec: 0n,
        grace_sec: 100n,
        take_rate_bps: 0n,
        collateral_rate_bps: 0n,
        max_discount_bps: 500n,
        vesting_bps_cycle1: 0n,
        early_lock_rate_bps_cycle1: 0n,
        commit_duration_sec: 5n,
        reveal_duration_sec: 5n,
        max_pot_cap: 10_000_000n,
        min_deposit_units: 1n
      })
    );
    await deployContract(circle, deployer, toNano("0.5"));

    await sendBody(
      jettonMaster,
      circle.address,
      beginCell().storeUint(OP_TAKE_WALLET_ADDRESS, 32).storeUint(1, 64).storeAddress(jettonWallet.address).endCell(),
      toNano("0.2")
    );

    const exp = blockchain.now + 600;
    await sendBody(
      memberA,
      circle.address,
      beginCell()
        .storeUint(OP_JOIN_WITH_TICKET, 32)
        .storeAddress(memberA.address)
        .storeUint(exp, 32)
        .storeUint(1n, 64)
        .storeBuffer(sign(buildJoinHash(circle.address, memberA.address, exp, 1n), guardianKeypair.secretKey))
        .endCell(),
      toNano("0.2")
    );
    await sendBody(
      memberB,
      circle.address,
      beginCell()
        .storeUint(OP_JOIN_WITH_TICKET, 32)
        .storeAddress(memberB.address)
        .storeUint(exp, 32)
        .storeUint(2n, 64)
        .storeBuffer(sign(buildJoinHash(circle.address, memberB.address, exp, 2n), guardianKeypair.secretKey))
        .endCell(),
      toNano("0.2")
    );

    await sendBody(
      deployer,
      jettonWallet.address,
      beginCell().storeUint(OP_TEST_SEND_NOTIFICATION, 32).storeAddress(circle.address).storeUint(11, 64).storeCoins(1_000_000n).storeAddress(memberA.address).storeUint(PURPOSE_PREFUND, 8).endCell(),
      toNano("0.2")
    );
    await sendBody(
      deployer,
      jettonWallet.address,
      beginCell().storeUint(OP_TEST_SEND_NOTIFICATION, 32).storeAddress(circle.address).storeUint(12, 64).storeCoins(1_000_000n).storeAddress(memberB.address).storeUint(PURPOSE_PREFUND, 8).endCell(),
      toNano("0.2")
    );

    const status = await circle.getGetStatus();
    expect(status.phase).toEqual(1n); // Commit

    // At now == commit_end, commit should be rejected (phase sync moves to Reveal).
    blockchain.now = Number(status.commit_end_at);
    const salt = u256From(randomBytes(32));
    const commitHash = u256From(buildBidHash(circle.address, 1, memberA.address, 2_000_000n, salt));
    const res = await sendBody(memberA, circle.address, beginCell().storeUint(OP_COMMIT_BID, 32).storeUint(commitHash, 256).endCell(), toNano("0.2"));
    expectTxFail(res, circle.address, ERR_NOT_COMMIT_PHASE);
  });

  it("rejects reveal at/after reveal_end (C19)", async () => {
    const memberA = await blockchain.treasury("revealLateA");
    const memberB = await blockchain.treasury("revealLateB");

    const jettonWallet = blockchain.openContract(await JettonWalletMock.fromInit(false));
    await deployContract(jettonWallet, deployer, toNano("0.2"));

    const circle = blockchain.openContract(
      await CircleContract.fromInit({
        $$type: "Config",
        jetton_master: jettonMaster.address,
        guardian_pubkey: u256From(guardianKeypair.publicKey),
        treasury_owner: treasuryOwner.address,
        n_members: 2n,
        contribution: 1_000_000n,
        total_cycles: 2n,
        interval_sec: 0n,
        grace_sec: 100n,
        take_rate_bps: 0n,
        collateral_rate_bps: 0n,
        max_discount_bps: 500n,
        vesting_bps_cycle1: 0n,
        early_lock_rate_bps_cycle1: 0n,
        commit_duration_sec: 5n,
        reveal_duration_sec: 5n,
        max_pot_cap: 10_000_000n,
        min_deposit_units: 1n
      })
    );
    await deployContract(circle, deployer, toNano("0.5"));

    await sendBody(
      jettonMaster,
      circle.address,
      beginCell().storeUint(OP_TAKE_WALLET_ADDRESS, 32).storeUint(1, 64).storeAddress(jettonWallet.address).endCell(),
      toNano("0.2")
    );

    const exp = blockchain.now + 600;
    await sendBody(
      memberA,
      circle.address,
      beginCell()
        .storeUint(OP_JOIN_WITH_TICKET, 32)
        .storeAddress(memberA.address)
        .storeUint(exp, 32)
        .storeUint(1n, 64)
        .storeBuffer(sign(buildJoinHash(circle.address, memberA.address, exp, 1n), guardianKeypair.secretKey))
        .endCell(),
      toNano("0.2")
    );
    await sendBody(
      memberB,
      circle.address,
      beginCell()
        .storeUint(OP_JOIN_WITH_TICKET, 32)
        .storeAddress(memberB.address)
        .storeUint(exp, 32)
        .storeUint(2n, 64)
        .storeBuffer(sign(buildJoinHash(circle.address, memberB.address, exp, 2n), guardianKeypair.secretKey))
        .endCell(),
      toNano("0.2")
    );

    await sendBody(
      deployer,
      jettonWallet.address,
      beginCell().storeUint(OP_TEST_SEND_NOTIFICATION, 32).storeAddress(circle.address).storeUint(11, 64).storeCoins(1_000_000n).storeAddress(memberA.address).storeUint(PURPOSE_PREFUND, 8).endCell(),
      toNano("0.2")
    );
    await sendBody(
      deployer,
      jettonWallet.address,
      beginCell().storeUint(OP_TEST_SEND_NOTIFICATION, 32).storeAddress(circle.address).storeUint(12, 64).storeCoins(1_000_000n).storeAddress(memberB.address).storeUint(PURPOSE_PREFUND, 8).endCell(),
      toNano("0.2")
    );

    const status = await circle.getGetStatus();
    expect(status.phase).toEqual(1n); // Commit

    // Commit once (within window)
    const payout = 2_000_000n;
    const salt = u256From(randomBytes(32));
    const commitHash = u256From(buildBidHash(circle.address, 1, memberA.address, payout, salt));
    const commitRes = await sendBody(memberA, circle.address, beginCell().storeUint(OP_COMMIT_BID, 32).storeUint(commitHash, 256).endCell(), toNano("0.2"));
    expectTxSuccess(commitRes, circle.address);

    // At now == reveal_end, reveal must be rejected (now < reveal_end required).
    blockchain.now = Number(status.reveal_end_at);
    const revealRes = await sendBody(memberA, circle.address, beginCell().storeUint(OP_REVEAL_BID, 32).storeCoins(payout).storeUint(salt, 256).endCell(), toNano("0.2"));
    expectTxFail(revealRes, circle.address, ERR_REVEAL_CLOSED);
  });

  it("rejects spoofed transfer_notification from sender != jetton_wallet (D27)", async () => {
    const memberA = await blockchain.treasury("spoofA");
    const memberB = await blockchain.treasury("spoofB");

    const jettonWallet = blockchain.openContract(await JettonWalletMock.fromInit(false));
    await deployContract(jettonWallet, deployer, toNano("0.2"));

    const circle = blockchain.openContract(
      await CircleContract.fromInit({
        $$type: "Config",
        jetton_master: jettonMaster.address,
        guardian_pubkey: u256From(guardianKeypair.publicKey),
        treasury_owner: treasuryOwner.address,
        n_members: 2n,
        contribution: 1_000_000n,
        total_cycles: 2n,
        interval_sec: 0n,
        grace_sec: 100n,
        take_rate_bps: 0n,
        collateral_rate_bps: 0n,
        max_discount_bps: 500n,
        vesting_bps_cycle1: 0n,
        early_lock_rate_bps_cycle1: 0n,
        commit_duration_sec: 5n,
        reveal_duration_sec: 5n,
        max_pot_cap: 10_000_000n,
        min_deposit_units: 1n
      })
    );
    await deployContract(circle, deployer, toNano("0.5"));

    await sendBody(
      jettonMaster,
      circle.address,
      beginCell().storeUint(OP_TAKE_WALLET_ADDRESS, 32).storeUint(1, 64).storeAddress(jettonWallet.address).endCell(),
      toNano("0.2")
    );

    const exp = blockchain.now + 600;
    await sendBody(
      memberA,
      circle.address,
      beginCell()
        .storeUint(OP_JOIN_WITH_TICKET, 32)
        .storeAddress(memberA.address)
        .storeUint(exp, 32)
        .storeUint(1n, 64)
        .storeBuffer(sign(buildJoinHash(circle.address, memberA.address, exp, 1n), guardianKeypair.secretKey))
        .endCell(),
      toNano("0.2")
    );
    await sendBody(
      memberB,
      circle.address,
      beginCell()
        .storeUint(OP_JOIN_WITH_TICKET, 32)
        .storeAddress(memberB.address)
        .storeUint(exp, 32)
        .storeUint(2n, 64)
        .storeBuffer(sign(buildJoinHash(circle.address, memberB.address, exp, 2n), guardianKeypair.secretKey))
        .endCell(),
      toNano("0.2")
    );

    const before = await circle.getGetMember(memberA.address);
    expect(before.prefund).toEqual(0n);

    const spoof = beginCell().storeUint(OP_JETTON_TRANSFER_NOTIFICATION, 32).endCell();
    const res = await sendBody(deployer, circle.address, spoof, toNano("0.2"));
    expectTxFail(res, circle.address, ERR_SENDER_NOT_JETTON_WALLET);

    const after = await circle.getGetMember(memberA.address);
    expect(after.prefund).toEqual(0n);
  });

  it("recruiting exit (mode=3) allows re-join and cannot exit after lock (H42/H45)", async () => {
    const memberA = await blockchain.treasury("exitA");
    const memberB = await blockchain.treasury("exitB");

    const circle = blockchain.openContract(
      await CircleContract.fromInit({
        $$type: "Config",
        jetton_master: jettonMaster.address,
        guardian_pubkey: u256From(guardianKeypair.publicKey),
        treasury_owner: treasuryOwner.address,
        n_members: 2n,
        contribution: 1_000_000n,
        total_cycles: 2n,
        interval_sec: 0n,
        grace_sec: 100n,
        take_rate_bps: 0n,
        collateral_rate_bps: 0n,
        max_discount_bps: 500n,
        vesting_bps_cycle1: 0n,
        early_lock_rate_bps_cycle1: 0n,
        commit_duration_sec: 5n,
        reveal_duration_sec: 5n,
        max_pot_cap: 10_000_000n,
        min_deposit_units: 1n
      })
    );
    await deployContract(circle, deployer, toNano("0.5"));

    const exp = blockchain.now + 600;
    const join1 = beginCell()
      .storeUint(OP_JOIN_WITH_TICKET, 32)
      .storeAddress(memberA.address)
      .storeUint(exp, 32)
      .storeUint(1n, 64)
      .storeBuffer(sign(buildJoinHash(circle.address, memberA.address, exp, 1n), guardianKeypair.secretKey))
      .endCell();
    const joinRes = await sendBody(memberA, circle.address, join1, toNano("0.2"));
    expectTxSuccess(joinRes, circle.address);
    expect(await circle.getGetMembersCount()).toEqual(1n);

    // Exit with no deposits (amount==0)
    const exitRes = await sendBody(memberA, circle.address, beginCell().storeUint(OP_WITHDRAW, 32).storeUint(3, 8).endCell(), toNano("0.05"));
    expectTxSuccess(exitRes, circle.address);
    expect(await circle.getGetMembersCount()).toEqual(0n);
    expect((await circle.getGetMember(memberA.address)).active).toBe(false);

    // Re-join with a new ticket (same wallet, different nonce)
    const join2 = beginCell()
      .storeUint(OP_JOIN_WITH_TICKET, 32)
      .storeAddress(memberA.address)
      .storeUint(exp, 32)
      .storeUint(2n, 64)
      .storeBuffer(sign(buildJoinHash(circle.address, memberA.address, exp, 2n), guardianKeypair.secretKey))
      .endCell();
    const rejoinRes = await sendBody(memberA, circle.address, join2, toNano("0.2"));
    expectTxSuccess(rejoinRes, circle.address);
    expect(await circle.getGetMembersCount()).toEqual(1n);
    expect((await circle.getGetMember(memberA.address)).active).toBe(true);

    // Fill to lock
    const joinB = beginCell()
      .storeUint(OP_JOIN_WITH_TICKET, 32)
      .storeAddress(memberB.address)
      .storeUint(exp, 32)
      .storeUint(1n, 64)
      .storeBuffer(sign(buildJoinHash(circle.address, memberB.address, exp, 1n), guardianKeypair.secretKey))
      .endCell();
    await sendBody(memberB, circle.address, joinB, toNano("0.2"));
    expect(await circle.getGetMembersCount()).toEqual(2n);
    expect((await circle.getGetStatus()).status).toEqual(1n); // Locked

    // Cannot exit after Locked
    const exitAfterLock = await sendBody(memberA, circle.address, beginCell().storeUint(OP_WITHDRAW, 32).storeUint(3, 8).endCell(), toNano("0.05"));
    expectTxFail(exitAfterLock, circle.address, ERR_NOT_RECRUITING);
  });

  it("no-bid fallback never selects has_won=true (fix #4 / C26)", async () => {
    const memberA = await blockchain.treasury("fallbackA");
    const memberB = await blockchain.treasury("fallbackB");

    const jettonWallet = blockchain.openContract(await JettonWalletMock.fromInit(false));
    await deployContract(jettonWallet, deployer, toNano("0.2"));

    const circle = blockchain.openContract(
      await CircleContract.fromInit({
        $$type: "Config",
        jetton_master: jettonMaster.address,
        guardian_pubkey: u256From(guardianKeypair.publicKey),
        treasury_owner: treasuryOwner.address,
        n_members: 2n,
        contribution: 1_000_000n,
        total_cycles: 2n,
        interval_sec: 0n,
        grace_sec: 3600n,
        take_rate_bps: 0n,
        collateral_rate_bps: 0n,
        max_discount_bps: 500n,
        vesting_bps_cycle1: 0n,
        early_lock_rate_bps_cycle1: 0n,
        commit_duration_sec: 5n,
        reveal_duration_sec: 5n,
        max_pot_cap: 10_000_000n,
        min_deposit_units: 1n
      })
    );
    await deployContract(circle, deployer, toNano("0.5"));

    await sendBody(
      jettonMaster,
      circle.address,
      beginCell().storeUint(OP_TAKE_WALLET_ADDRESS, 32).storeUint(1, 64).storeAddress(jettonWallet.address).endCell(),
      toNano("0.2")
    );

    const exp = blockchain.now + 600;
    await sendBody(
      memberA,
      circle.address,
      beginCell()
        .storeUint(OP_JOIN_WITH_TICKET, 32)
        .storeAddress(memberA.address)
        .storeUint(exp, 32)
        .storeUint(1n, 64)
        .storeBuffer(sign(buildJoinHash(circle.address, memberA.address, exp, 1n), guardianKeypair.secretKey))
        .endCell(),
      toNano("0.2")
    );
    await sendBody(
      memberB,
      circle.address,
      beginCell()
        .storeUint(OP_JOIN_WITH_TICKET, 32)
        .storeAddress(memberB.address)
        .storeUint(exp, 32)
        .storeUint(2n, 64)
        .storeBuffer(sign(buildJoinHash(circle.address, memberB.address, exp, 2n), guardianKeypair.secretKey))
        .endCell(),
      toNano("0.2")
    );

    // Fund cycle 1 (auto-debit-on-deposit)
    for (const [qid, who] of [
      [11, memberA],
      [12, memberB]
    ] as const) {
      await sendBody(
        deployer,
        jettonWallet.address,
        beginCell().storeUint(OP_TEST_SEND_NOTIFICATION, 32).storeAddress(circle.address).storeUint(qid, 64).storeCoins(1_000_000n).storeAddress(who.address).storeUint(PURPOSE_PREFUND, 8).endCell(),
        toNano("0.2")
      );
    }

    // Cycle 1: both reveal, memberA wins by bidding lower.
    const pot = 2_000_000n;
    const payoutA = 1_900_000n;
    const saltA = u256From(randomBytes(32));
    const commitHashA = u256From(buildBidHash(circle.address, 1, memberA.address, payoutA, saltA));
    await sendBody(memberA, circle.address, beginCell().storeUint(OP_COMMIT_BID, 32).storeUint(commitHashA, 256).endCell(), toNano("0.2"));
    const payoutB = pot;
    const saltB = u256From(randomBytes(32));
    const commitHashB = u256From(buildBidHash(circle.address, 1, memberB.address, payoutB, saltB));
    await sendBody(memberB, circle.address, beginCell().storeUint(OP_COMMIT_BID, 32).storeUint(commitHashB, 256).endCell(), toNano("0.2"));

    blockchain.now = blockchain.now + 5; // commit_end
    await sendBody(memberA, circle.address, beginCell().storeUint(OP_REVEAL_BID, 32).storeCoins(payoutA).storeUint(saltA, 256).endCell(), toNano("0.2"));
    await sendBody(memberB, circle.address, beginCell().storeUint(OP_REVEAL_BID, 32).storeCoins(payoutB).storeUint(saltB, 256).endCell(), toNano("0.2"));

    blockchain.now = blockchain.now + 5; // reveal_end
    await sendBody(memberA, circle.address, beginCell().storeUint(OP_FINALIZE_AUCTION, 32).endCell(), toNano("0.2"));

    // Clear memberA withdrawable so we can detect accidental second win.
    const aAfter1 = await circle.getGetMember(memberA.address);
    expect(aAfter1.has_won).toBe(true);
    expect(aAfter1.withdrawable).toBeGreaterThan(0n);
    await sendBody(memberA, circle.address, beginCell().storeUint(OP_WITHDRAW, 32).storeUint(1, 8).endCell(), toNano("0.2"));
    expect((await circle.getGetMember(memberA.address)).withdrawable).toEqual(0n);

    // Fund cycle 2 and open commit window again.
    for (const [qid, who] of [
      [21, memberA],
      [22, memberB]
    ] as const) {
      await sendBody(
        deployer,
        jettonWallet.address,
        beginCell().storeUint(OP_TEST_SEND_NOTIFICATION, 32).storeAddress(circle.address).storeUint(qid, 64).storeCoins(1_000_000n).storeAddress(who.address).storeUint(PURPOSE_PREFUND, 8).endCell(),
        toNano("0.2")
      );
    }

    const st2 = await circle.getGetStatus();
    expect(st2.current_cycle).toEqual(2n);
    expect(st2.phase).toEqual(1n); // Commit

    // No commits/reveals in cycle 2 -> fallback winner must be memberB (has_won=false).
    blockchain.now = Number(st2.reveal_end_at);
    await sendBody(memberB, circle.address, beginCell().storeUint(OP_FINALIZE_AUCTION, 32).endCell(), toNano("0.2"));

    const aAfter2 = await circle.getGetMember(memberA.address);
    const bAfter2 = await circle.getGetMember(memberB.address);
    expect(aAfter2.withdrawable).toEqual(0n);
    expect(bAfter2.has_won).toBe(true);
    expect(bAfter2.withdrawable).toBeGreaterThan(0n);
  });

  it("EmergencyStop nonce replay is rejected and blocks ops (E34/I46)", async () => {
    const memberA = await blockchain.treasury("stopA");
    const memberB = await blockchain.treasury("stopB");

    const jettonWallet = blockchain.openContract(await JettonWalletMock.fromInit(false));
    await deployContract(jettonWallet, deployer, toNano("0.2"));

    const circle = blockchain.openContract(
      await CircleContract.fromInit({
        $$type: "Config",
        jetton_master: jettonMaster.address,
        guardian_pubkey: u256From(guardianKeypair.publicKey),
        treasury_owner: treasuryOwner.address,
        n_members: 2n,
        contribution: 1_000_000n,
        total_cycles: 2n,
        interval_sec: 0n,
        grace_sec: 3600n,
        take_rate_bps: 0n,
        collateral_rate_bps: 0n,
        max_discount_bps: 500n,
        vesting_bps_cycle1: 0n,
        early_lock_rate_bps_cycle1: 0n,
        commit_duration_sec: 5n,
        reveal_duration_sec: 5n,
        max_pot_cap: 10_000_000n,
        min_deposit_units: 1n
      })
    );
    await deployContract(circle, deployer, toNano("0.5"));

    await sendBody(
      jettonMaster,
      circle.address,
      beginCell().storeUint(OP_TAKE_WALLET_ADDRESS, 32).storeUint(1, 64).storeAddress(jettonWallet.address).endCell(),
      toNano("0.2")
    );

    const exp = blockchain.now + 600;
    await sendBody(
      memberA,
      circle.address,
      beginCell()
        .storeUint(OP_JOIN_WITH_TICKET, 32)
        .storeAddress(memberA.address)
        .storeUint(exp, 32)
        .storeUint(1n, 64)
        .storeBuffer(sign(buildJoinHash(circle.address, memberA.address, exp, 1n), guardianKeypair.secretKey))
        .endCell(),
      toNano("0.2")
    );
    await sendBody(
      memberB,
      circle.address,
      beginCell()
        .storeUint(OP_JOIN_WITH_TICKET, 32)
        .storeAddress(memberB.address)
        .storeUint(exp, 32)
        .storeUint(2n, 64)
        .storeBuffer(sign(buildJoinHash(circle.address, memberB.address, exp, 2n), guardianKeypair.secretKey))
        .endCell(),
      toNano("0.2")
    );

    // Fund to open commit window (and leave extra prefund for memberA so WITHDRAW_ALL has something).
    await sendBody(
      deployer,
      jettonWallet.address,
      beginCell().storeUint(OP_TEST_SEND_NOTIFICATION, 32).storeAddress(circle.address).storeUint(11, 64).storeCoins(2_000_000n).storeAddress(memberA.address).storeUint(PURPOSE_PREFUND, 8).endCell(),
      toNano("0.2")
    );
    await sendBody(
      deployer,
      jettonWallet.address,
      beginCell().storeUint(OP_TEST_SEND_NOTIFICATION, 32).storeAddress(circle.address).storeUint(12, 64).storeCoins(1_000_000n).storeAddress(memberB.address).storeUint(PURPOSE_PREFUND, 8).endCell(),
      toNano("0.2")
    );
    expect((await circle.getGetStatus()).phase).toEqual(1n); // Commit

    // Emergency stop
    const reason = 1;
    const stopExp = blockchain.now + 10_000;
    const stopNonce = 1n;
    const stopSig = sign(buildStopHash(circle.address, reason, stopExp, stopNonce), guardianKeypair.secretKey);
    const stopMsg = beginCell()
      .storeUint(OP_EMERGENCY_STOP, 32)
      .storeUint(reason, 32)
      .storeUint(stopExp, 32)
      .storeUint(stopNonce, 64)
      .storeBuffer(stopSig)
      .endCell();
    const stopRes = await sendBody(deployer, circle.address, stopMsg, toNano("0.2"));
    expectTxSuccess(stopRes, circle.address);
    expect((await circle.getGetStatus()).status).toEqual(5n); // EmergencyStop

    // Nonce replay rejected
    const stopRes2 = await sendBody(deployer, circle.address, stopMsg, toNano("0.2"));
    expectTxFail(stopRes2, circle.address, ERR_STOP_NONCE_USED);

    // Commit is blocked during EmergencyStop
    const salt = u256From(randomBytes(32));
    const commitHash = u256From(buildBidHash(circle.address, 1, memberA.address, 2_000_000n, salt));
    const commitTry = await sendBody(memberA, circle.address, beginCell().storeUint(OP_COMMIT_BID, 32).storeUint(commitHash, 256).endCell(), toNano("0.2"));
    expectTxFail(commitTry, circle.address, ERR_EMERGENCY_STOP);
  });

  it("skips already-won member in fallback rotation (fix #4)", async () => {
    const memberA = await blockchain.treasury("memberA");
    const memberB = await blockchain.treasury("memberB");
    const memberC = await blockchain.treasury("memberC");

    const jettonWallet = blockchain.openContract(await JettonWalletMock.fromInit(false));
    await deployContract(jettonWallet, deployer, toNano("0.2"));

    const circle = blockchain.openContract(
      await CircleContract.fromInit({
        $$type: "Config",
        jetton_master: jettonMaster.address,
        guardian_pubkey: u256From(guardianKeypair.publicKey),
        treasury_owner: treasuryOwner.address,
        n_members: 3n,
        contribution: 1_000_000n,
        total_cycles: 3n,
        interval_sec: 0n,
        grace_sec: 3600n,
        take_rate_bps: 100n,
        collateral_rate_bps: 0n,
        max_discount_bps: 500n,
        vesting_bps_cycle1: 0n,
        early_lock_rate_bps_cycle1: 0n,
        commit_duration_sec: 10n,
        reveal_duration_sec: 10n,
        max_pot_cap: 10_000_000n,
        min_deposit_units: 1n
      })
    );
    await deployContract(circle, deployer, toNano("0.5"));

    // Set jetton_wallet
    await sendBody(
      jettonMaster,
      circle.address,
      beginCell().storeUint(OP_TAKE_WALLET_ADDRESS, 32).storeUint(1, 64).storeAddress(jettonWallet.address).endCell(),
      toNano("0.2")
    );

    // Join A,B,C (B will win cycle 1)
    const exp = blockchain.now + 600;
    for (const [nonce, who] of [
      [1n, memberA],
      [2n, memberB],
      [3n, memberC]
    ] as const) {
      await sendBody(
        who,
        circle.address,
        beginCell()
          .storeUint(OP_JOIN_WITH_TICKET, 32)
          .storeAddress(who.address)
          .storeUint(exp, 32)
          .storeUint(nonce, 64)
          .storeBuffer(sign(buildJoinHash(circle.address, who.address, exp, nonce), guardianKeypair.secretKey))
          .endCell(),
        toNano("0.2")
      );
    }

    expect(await circle.getGetMembersCount()).toEqual(3n);

    // Fund cycle 1
    for (const [qid, who] of [
      [11, memberA],
      [12, memberB],
      [13, memberC]
    ] as const) {
      await sendBody(
        deployer,
        jettonWallet.address,
        beginCell().storeUint(OP_TEST_SEND_NOTIFICATION, 32).storeAddress(circle.address).storeUint(qid, 64).storeCoins(1_000_000n).storeAddress(who.address).storeUint(PURPOSE_PREFUND, 8).endCell(),
        toNano("0.2")
      );
    }

    const statusAfterFunding = await circle.getGetStatus();
    expect(statusAfterFunding.status).toEqual(2n); // Active
    expect(statusAfterFunding.phase).toEqual(1n); // Commit
    expect(statusAfterFunding.funded_count).toEqual(3n);

    // Commit bids so that memberB wins (lowest payoutWanted)
    const pot = 3_000_000n;
    const minPayout = 2_850_000n; // pot*(1-5%)
    const saltA = u256From(randomBytes(32));
    const saltB = u256From(randomBytes(32));
    const saltC = u256From(randomBytes(32));
    const commitA = u256From(buildBidHash(circle.address, 1, memberA.address, pot, saltA));
    const commitB = u256From(buildBidHash(circle.address, 1, memberB.address, minPayout, saltB));
    const commitC = u256From(buildBidHash(circle.address, 1, memberC.address, pot, saltC));
    await sendBody(memberA, circle.address, beginCell().storeUint(OP_COMMIT_BID, 32).storeUint(commitA, 256).endCell(), toNano("0.2"));
    await sendBody(memberB, circle.address, beginCell().storeUint(OP_COMMIT_BID, 32).storeUint(commitB, 256).endCell(), toNano("0.2"));
    await sendBody(memberC, circle.address, beginCell().storeUint(OP_COMMIT_BID, 32).storeUint(commitC, 256).endCell(), toNano("0.2"));

    // Reveal in time
    blockchain.now += 10;
    await sendBody(memberA, circle.address, beginCell().storeUint(OP_REVEAL_BID, 32).storeCoins(pot).storeUint(saltA, 256).endCell(), toNano("0.2"));
    await sendBody(memberB, circle.address, beginCell().storeUint(OP_REVEAL_BID, 32).storeCoins(minPayout).storeUint(saltB, 256).endCell(), toNano("0.2"));
    await sendBody(memberC, circle.address, beginCell().storeUint(OP_REVEAL_BID, 32).storeCoins(pot).storeUint(saltC, 256).endCell(), toNano("0.2"));

    // Finalize cycle 1
    blockchain.now += 10;
    await sendBody(memberA, circle.address, beginCell().storeUint(OP_FINALIZE_AUCTION, 32).endCell(), toNano("0.2"));

    // Clear memberB withdrawable to detect accidental second win
    const bAfterC1 = await circle.getGetMember(memberB.address);
    expect(bAfterC1.has_won).toEqual(true);
    expect(bAfterC1.withdrawable).toBeGreaterThan(0n);
    await sendBody(memberB, circle.address, beginCell().storeUint(OP_WITHDRAW, 32).storeUint(1, 8).endCell(), toNano("0.2"));
    expect((await circle.getGetMember(memberB.address)).withdrawable).toEqual(0n);

    // Fund cycle 2 (open commit window), then finalize with no commits/reveals => fallback rotation
    for (const [qid, who] of [
      [21, memberA],
      [22, memberB],
      [23, memberC]
    ] as const) {
      await sendBody(
        deployer,
        jettonWallet.address,
        beginCell().storeUint(OP_TEST_SEND_NOTIFICATION, 32).storeAddress(circle.address).storeUint(qid, 64).storeCoins(1_000_000n).storeAddress(who.address).storeUint(PURPOSE_PREFUND, 8).endCell(),
        toNano("0.2")
      );
    }
    await sendBody(memberA, circle.address, beginCell().storeUint(OP_TRIGGER_DEBIT_ALL, 32).endCell(), toNano("0.2"));
    const statusC2 = await circle.getGetStatus();
    expect(statusC2.current_cycle).toEqual(2n);
    expect(statusC2.phase).toEqual(1n); // Commit

    // Let commit+reveal windows pass; no bids => fallback. Cycle 2 start index=1 points to memberB (already won), so should pick memberC.
    blockchain.now += 20;
    await sendBody(memberA, circle.address, beginCell().storeUint(OP_FINALIZE_AUCTION, 32).endCell(), toNano("0.2"));

    const bAfterC2 = await circle.getGetMember(memberB.address);
    const cAfterC2 = await circle.getGetMember(memberC.address);
    expect(bAfterC2.withdrawable).toEqual(0n);
    expect(cAfterC2.has_won).toEqual(true);
    expect(cAfterC2.withdrawable).toBeGreaterThan(0n);
  });

  it("allows recruiting exit (fix #5): cancel join + withdraw deposits, swap-with-last member_list", async () => {
    const memberA = await blockchain.treasury("memberA");
    const memberB = await blockchain.treasury("memberB");

    const jettonWallet = blockchain.openContract(await JettonWalletMock.fromInit(false));
    await deployContract(jettonWallet, deployer, toNano("0.2"));

    const circle = blockchain.openContract(
      await CircleContract.fromInit({
        $$type: "Config",
        jetton_master: jettonMaster.address,
        guardian_pubkey: u256From(guardianKeypair.publicKey),
        treasury_owner: treasuryOwner.address,
        n_members: 3n,
        contribution: 1_000_000n,
        total_cycles: 3n,
        interval_sec: 0n,
        grace_sec: 3600n,
        take_rate_bps: 100n,
        collateral_rate_bps: 0n,
        max_discount_bps: 500n,
        vesting_bps_cycle1: 0n,
        early_lock_rate_bps_cycle1: 0n,
        commit_duration_sec: 10n,
        reveal_duration_sec: 10n,
        max_pot_cap: 10_000_000n,
        min_deposit_units: 1n
      })
    );
    await deployContract(circle, deployer, toNano("0.5"));

    // Set jetton_wallet
    await sendBody(
      jettonMaster,
      circle.address,
      beginCell().storeUint(OP_TAKE_WALLET_ADDRESS, 32).storeUint(1, 64).storeAddress(jettonWallet.address).endCell(),
      toNano("0.2")
    );

    // Join A then B (circle stays Recruiting because N=3)
    const exp = blockchain.now + 600;
    await sendBody(
      memberA,
      circle.address,
      beginCell()
        .storeUint(OP_JOIN_WITH_TICKET, 32)
        .storeAddress(memberA.address)
        .storeUint(exp, 32)
        .storeUint(1n, 64)
        .storeBuffer(sign(buildJoinHash(circle.address, memberA.address, exp, 1n), guardianKeypair.secretKey))
        .endCell(),
      toNano("0.2")
    );
    await sendBody(
      memberB,
      circle.address,
      beginCell()
        .storeUint(OP_JOIN_WITH_TICKET, 32)
        .storeAddress(memberB.address)
        .storeUint(exp, 32)
        .storeUint(2n, 64)
        .storeBuffer(sign(buildJoinHash(circle.address, memberB.address, exp, 2n), guardianKeypair.secretKey))
        .endCell(),
      toNano("0.2")
    );

    const statusRecruiting = await circle.getGetStatus();
    expect(statusRecruiting.status).toEqual(0n); // Recruiting
    expect(await circle.getGetMembersCount()).toEqual(2n);

    // Deposit collateral+prefund for A while still Recruiting
    await sendBody(
      deployer,
      jettonWallet.address,
      beginCell().storeUint(OP_TEST_SEND_NOTIFICATION, 32).storeAddress(circle.address).storeUint(11, 64).storeCoins(123_000n).storeAddress(memberA.address).storeUint(PURPOSE_COLLATERAL, 8).endCell(),
      toNano("0.2")
    );
    await sendBody(
      deployer,
      jettonWallet.address,
      beginCell().storeUint(OP_TEST_SEND_NOTIFICATION, 32).storeAddress(circle.address).storeUint(12, 64).storeCoins(1_000_000n).storeAddress(memberA.address).storeUint(PURPOSE_PREFUND, 8).endCell(),
      toNano("0.2")
    );

    const aBefore = await circle.getGetMember(memberA.address);
    expect(aBefore.active).toEqual(true);
    expect(aBefore.collateral).toEqual(123_000n);
    expect(aBefore.prefund).toEqual(1_000_000n);

    // A exits (mode=3): cancel + withdraw deposits
    await sendBody(memberA, circle.address, beginCell().storeUint(OP_WITHDRAW, 32).storeUint(3, 8).endCell(), toNano("0.2"));

    expect(await circle.getGetMembersCount()).toEqual(1n);
    const aAfter = await circle.getGetMember(memberA.address);
    expect(aAfter.active).toEqual(false);
    expect(aAfter.collateral).toEqual(0n);
    expect(aAfter.prefund).toEqual(0n);

    // Member list should have swapped B into index 0
    const memberAt0 = await circle.getGetMemberAt(0n);
    expect(memberAt0.toString()).toEqual(memberB.address.toString());
  });

  it("restores withdrawable on jetton transfer bounce (outbox)", async () => {
    const memberA = await blockchain.treasury("memberA");
    const memberB = await blockchain.treasury("memberB");

    const jettonWallet = blockchain.openContract(await JettonWalletMock.fromInit(false));
    await deployContract(jettonWallet, deployer, toNano("0.2"));

    const circle = blockchain.openContract(
      await CircleContract.fromInit({
        $$type: "Config",
        jetton_master: jettonMaster.address,
        guardian_pubkey: u256From(guardianKeypair.publicKey),
        treasury_owner: treasuryOwner.address,
        n_members: 2n,
        contribution: 1_000_000n,
        total_cycles: 2n,
        interval_sec: 0n,
        grace_sec: 3600n,
        take_rate_bps: 100n,
        collateral_rate_bps: 0n,
        max_discount_bps: 500n,
        vesting_bps_cycle1: 0n,
        early_lock_rate_bps_cycle1: 0n,
        commit_duration_sec: 10n,
        reveal_duration_sec: 10n,
        max_pot_cap: 10_000_000n,
        min_deposit_units: 1n
      })
    );
    await deployContract(circle, deployer, toNano("0.5"));

    // Set jetton_wallet
    await sendBody(
      jettonMaster,
      circle.address,
      beginCell().storeUint(OP_TAKE_WALLET_ADDRESS, 32).storeUint(1, 64).storeAddress(jettonWallet.address).endCell(),
      toNano("0.2")
    );

    // Join 2 members
    const exp = blockchain.now + 600;
    for (const [nonce, who] of [
      [1n, memberA],
      [2n, memberB]
    ] as const) {
      await sendBody(
        who,
        circle.address,
        beginCell()
          .storeUint(OP_JOIN_WITH_TICKET, 32)
          .storeAddress(who.address)
          .storeUint(exp, 32)
          .storeUint(nonce, 64)
          .storeBuffer(sign(buildJoinHash(circle.address, who.address, exp, nonce), guardianKeypair.secretKey))
          .endCell(),
        toNano("0.2")
      );
    }

    // Fund cycle 1
    for (const [qid, who] of [
      [11, memberA],
      [12, memberB]
    ] as const) {
      await sendBody(
        deployer,
        jettonWallet.address,
        beginCell().storeUint(OP_TEST_SEND_NOTIFICATION, 32).storeAddress(circle.address).storeUint(qid, 64).storeCoins(1_000_000n).storeAddress(who.address).storeUint(PURPOSE_PREFUND, 8).endCell(),
        toNano("0.2")
      );
    }

    // A wins (slightly lower payoutWanted)
    const pot = 2_000_000n;
    const payoutA = 1_900_000n;
    const payoutB = pot;
    const saltA = u256From(randomBytes(32));
    const saltB = u256From(randomBytes(32));
    const commitA = u256From(buildBidHash(circle.address, 1, memberA.address, payoutA, saltA));
    const commitB = u256From(buildBidHash(circle.address, 1, memberB.address, payoutB, saltB));
    await sendBody(memberA, circle.address, beginCell().storeUint(OP_COMMIT_BID, 32).storeUint(commitA, 256).endCell(), toNano("0.2"));
    await sendBody(memberB, circle.address, beginCell().storeUint(OP_COMMIT_BID, 32).storeUint(commitB, 256).endCell(), toNano("0.2"));

    blockchain.now += 10;
    await sendBody(memberA, circle.address, beginCell().storeUint(OP_REVEAL_BID, 32).storeCoins(payoutA).storeUint(saltA, 256).endCell(), toNano("0.2"));
    await sendBody(memberB, circle.address, beginCell().storeUint(OP_REVEAL_BID, 32).storeCoins(payoutB).storeUint(saltB, 256).endCell(), toNano("0.2"));

    blockchain.now += 10;
    await sendBody(memberA, circle.address, beginCell().storeUint(OP_FINALIZE_AUCTION, 32).endCell(), toNano("0.2"));

    const aBeforeWithdraw = await circle.getGetMember(memberA.address);
    expect(aBeforeWithdraw.withdrawable).toBeGreaterThan(0n);

    // Make jetton wallet bounce transfer.
    await sendBody(deployer, jettonWallet.address, beginCell().storeUint(OP_TEST_SET_BOUNCE, 32).storeUint(1, 1).endCell(), toNano("0.2"));
    expect(await jettonWallet.getGetShouldBounce()).toEqual(true);

    // Withdraw payout-only; transfer bounces => withdrawable restored.
    const expected = aBeforeWithdraw.withdrawable;
    await sendBody(memberA, circle.address, beginCell().storeUint(OP_WITHDRAW, 32).storeUint(1, 8).endCell(), toNano("0.2"));
    const aAfterWithdraw = await circle.getGetMember(memberA.address);
    expect(aAfterWithdraw.withdrawable).toEqual(expected);
  });

  it("is idempotent under TRIGGER_DEBIT_ALL spam (A1)", async () => {
    const memberA = await blockchain.treasury("spamA");
    const memberB = await blockchain.treasury("spamB");
    const memberC = await blockchain.treasury("spamC");

    const jettonWallet = blockchain.openContract(await JettonWalletMock.fromInit(false));
    await deployContract(jettonWallet, deployer, toNano("0.2"));

    const circle = blockchain.openContract(
      await CircleContract.fromInit({
        $$type: "Config",
        jetton_master: jettonMaster.address,
        guardian_pubkey: u256From(guardianKeypair.publicKey),
        treasury_owner: treasuryOwner.address,
        n_members: 3n,
        contribution: 1_000_000n,
        total_cycles: 3n,
        interval_sec: 0n,
        grace_sec: 3600n,
        take_rate_bps: 0n,
        collateral_rate_bps: 0n,
        max_discount_bps: 500n,
        vesting_bps_cycle1: 0n,
        early_lock_rate_bps_cycle1: 0n,
        commit_duration_sec: 10n,
        reveal_duration_sec: 10n,
        max_pot_cap: 10_000_000n,
        min_deposit_units: 1n
      })
    );
    await deployContract(circle, deployer, toNano("0.5"));

    // Set jetton_wallet
    await sendBody(
      jettonMaster,
      circle.address,
      beginCell().storeUint(OP_TAKE_WALLET_ADDRESS, 32).storeUint(1, 64).storeAddress(jettonWallet.address).endCell(),
      toNano("0.2")
    );

    // Join A,B,C
    const exp = blockchain.now + 600;
    for (const [nonce, who] of [
      [1n, memberA],
      [2n, memberB],
      [3n, memberC]
    ] as const) {
      await sendBody(
        who,
        circle.address,
        beginCell()
          .storeUint(OP_JOIN_WITH_TICKET, 32)
          .storeAddress(who.address)
          .storeUint(exp, 32)
          .storeUint(nonce, 64)
          .storeBuffer(sign(buildJoinHash(circle.address, who.address, exp, nonce), guardianKeypair.secretKey))
          .endCell(),
        toNano("0.2")
      );
    }

    // Only fund A (auto-debit-on-deposit)
    await sendBody(
      deployer,
      jettonWallet.address,
      beginCell().storeUint(OP_TEST_SEND_NOTIFICATION, 32).storeAddress(circle.address).storeUint(11, 64).storeCoins(1_000_000n).storeAddress(memberA.address).storeUint(PURPOSE_PREFUND, 8).endCell(),
      toNano("0.2")
    );

    expect((await circle.getGetStatus()).funded_count).toEqual(1n);
    expect((await circle.getGetMember(memberA.address)).due_remaining).toEqual(0n);

    // Spam TRIGGER_DEBIT_ALL: must not double debit A or move state incorrectly.
    const trigger = beginCell().storeUint(OP_TRIGGER_DEBIT_ALL, 32).endCell();
    for (let i = 0; i < 100; i++) {
      const res = await sendBody(memberB, circle.address, trigger, toNano("0.2"));
      expectTxSuccess(res, circle.address);
    }

    expect((await circle.getGetStatus()).funded_count).toEqual(1n);
    expect((await circle.getGetMember(memberA.address)).due_remaining).toEqual(0n);

    // Fund B and C and ensure we can still reach Commit phase cleanly.
    for (const [qid, who] of [
      [21, memberB],
      [22, memberC]
    ] as const) {
      await sendBody(
        deployer,
        jettonWallet.address,
        beginCell().storeUint(OP_TEST_SEND_NOTIFICATION, 32).storeAddress(circle.address).storeUint(qid, 64).storeCoins(1_000_000n).storeAddress(who.address).storeUint(PURPOSE_PREFUND, 8).endCell(),
        toNano("0.2")
      );
    }

    await sendBody(memberA, circle.address, trigger, toNano("0.2"));
    const st = await circle.getGetStatus();
    expect(st.funded_count).toEqual(3n);
    expect(st.phase).toEqual(1n); // Commit
  });

  it("enforces exclusive grace end: at now==grace_end_at, debit blocked and terminate allowed (A4/B9)", async () => {
    const memberA = await blockchain.treasury("graceA");
    const memberB = await blockchain.treasury("graceB");

    const jettonWallet = blockchain.openContract(await JettonWalletMock.fromInit(false));
    await deployContract(jettonWallet, deployer, toNano("0.2"));

    const circle = blockchain.openContract(
      await CircleContract.fromInit({
        $$type: "Config",
        jetton_master: jettonMaster.address,
        guardian_pubkey: u256From(guardianKeypair.publicKey),
        treasury_owner: treasuryOwner.address,
        n_members: 2n,
        contribution: 1_000_000n,
        total_cycles: 2n,
        interval_sec: 0n,
        grace_sec: 100n,
        take_rate_bps: 0n,
        collateral_rate_bps: 0n,
        max_discount_bps: 500n,
        vesting_bps_cycle1: 0n,
        early_lock_rate_bps_cycle1: 0n,
        commit_duration_sec: 10n,
        reveal_duration_sec: 10n,
        max_pot_cap: 10_000_000n,
        min_deposit_units: 1n
      })
    );
    await deployContract(circle, deployer, toNano("0.5"));

    // Set jetton_wallet
    await sendBody(
      jettonMaster,
      circle.address,
      beginCell().storeUint(OP_TAKE_WALLET_ADDRESS, 32).storeUint(1, 64).storeAddress(jettonWallet.address).endCell(),
      toNano("0.2")
    );

    // Join A,B
    const exp = blockchain.now + 600;
    await sendBody(
      memberA,
      circle.address,
      beginCell()
        .storeUint(OP_JOIN_WITH_TICKET, 32)
        .storeAddress(memberA.address)
        .storeUint(exp, 32)
        .storeUint(1n, 64)
        .storeBuffer(sign(buildJoinHash(circle.address, memberA.address, exp, 1n), guardianKeypair.secretKey))
        .endCell(),
      toNano("0.2")
    );
    await sendBody(
      memberB,
      circle.address,
      beginCell()
        .storeUint(OP_JOIN_WITH_TICKET, 32)
        .storeAddress(memberB.address)
        .storeUint(exp, 32)
        .storeUint(2n, 64)
        .storeBuffer(sign(buildJoinHash(circle.address, memberB.address, exp, 2n), guardianKeypair.secretKey))
        .endCell(),
      toNano("0.2")
    );

    // Fund only A
    await sendBody(
      deployer,
      jettonWallet.address,
      beginCell().storeUint(OP_TEST_SEND_NOTIFICATION, 32).storeAddress(circle.address).storeUint(11, 64).storeCoins(1_000_000n).storeAddress(memberA.address).storeUint(PURPOSE_PREFUND, 8).endCell(),
      toNano("0.2")
    );
    expect((await circle.getGetStatus()).funded_count).toEqual(1n);

    const st0 = await circle.getGetStatus();

    // Before grace_end: terminate must be rejected (not DefaultEligible yet).
    blockchain.now = Number(st0.grace_end_at) - 1;
    const terminateEarly = await sendBody(memberA, circle.address, beginCell().storeUint(OP_TERMINATE_DEFAULT, 32).endCell(), toNano("0.2"));
    expectTxFail(terminateEarly, circle.address, ERR_NOT_DEFAULT_ELIGIBLE);

    // At grace_end: phase sync moves to DefaultEligible, debit is blocked.
    blockchain.now = Number(st0.grace_end_at);
    const trigger = await sendBody(memberA, circle.address, beginCell().storeUint(OP_TRIGGER_DEBIT_ALL, 32).endCell(), toNano("0.2"));
    expectTxFail(trigger, circle.address, ERR_NOT_FUNDING_PHASE);

    const terminate = await sendBody(memberA, circle.address, beginCell().storeUint(OP_TERMINATE_DEFAULT, 32).endCell(), toNano("0.2"));
    expectTxSuccess(terminate, circle.address);
    expect((await circle.getGetStatus()).status).toEqual(4n); // Terminated
  });
});
